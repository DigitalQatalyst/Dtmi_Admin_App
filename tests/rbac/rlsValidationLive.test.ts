/**
 * RLS Validation Live Test
 * 
 * This test validates that Supabase Row Level Security (RLS) and RBAC rules
 * are functioning correctly with live data after switching from mock data mode.
 * 
 * Test Scenarios:
 * 1. Staff user (DigitalQatalyst) - should see records across multiple organizations
 * 2. Partner user (Beta Industries) - should see only records with matching organisation_id
 * 3. Enterprise user (Enterprise Corp) - should see 0 records or get 403 error
 */

import { createClient } from '@supabase/supabase-js';
import { describe, test, expect, beforeAll } from '@jest/globals';

// Environment variables for Supabase connection
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

// Check if we're in a test environment that requires Supabase
const REQUIRES_SUPABASE = process.env.NODE_ENV === 'test' && process.env.REQUIRE_SUPABASE === 'true';

if (REQUIRES_SUPABASE && (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY)) {
  throw new Error(`
Missing required environment variables for Supabase testing:
- SUPABASE_URL
- SUPABASE_SERVICE_ROLE_KEY

To run these tests:
1. Create a .env.test file with your Supabase credentials
2. Set REQUIRE_SUPABASE=true in your environment
3. Or skip these tests by not setting REQUIRE_SUPABASE

Example .env.test:
SUPABASE_URL=your_supabase_project_url
SUPABASE_SERVICE_ROLE_KEY=your_supabase_service_role_key
REQUIRE_SUPABASE=true
  `);
}

// Create Supabase client with service role key for testing (only if credentials are available)
const supabase = SUPABASE_URL && SUPABASE_SERVICE_ROLE_KEY 
  ? createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)
  : null;

// Test user configurations
const TEST_USERS = {
  staff: {
    email: 'admin@digitalqatalyst.com',
    customerType: 'staff',
    userRole: 'admin',
    organisationName: 'DigitalQatalyst',
    expectedAccess: 'multi-org'
  },
  partner: {
    email: 'partner.admin@partner1org.com',
    customerType: 'partner',
    userRole: 'admin',
    organisationName: 'partner1org',
    expectedAccess: 'single-org'
  },
  enterprise: {
    email: 'enterprise.admin@enterpriseorg.com',
    customerType: 'enterprise',
    userRole: 'admin',
    organisationName: 'enterpriseorg',
    expectedAccess: 'blocked'
  }
};

// Mock JWT tokens for testing (these would be generated by the auth system)
const MOCK_TOKENS = {
  staff: 'mock-staff-token',
  partner: 'mock-partner-token',
  enterprise: 'mock-enterprise-token'
};

/**
 * Helper function to set up Supabase session with mock user context
 */
async function setupSupabaseSession(userConfig: typeof TEST_USERS.staff) {
  if (!supabase) {
    console.warn('Supabase client not available');
    return;
  }

  try {
    // Set PostgreSQL context variables for RLS using RPC function
    const { error } = await supabase.rpc('set_current_user_context', {
      user_id: `mock-${userConfig.email.replace('@', '-').replace('.', '-')}`,
      customer_type: userConfig.customerType,
      user_role: userConfig.userRole,
      organisation_name: userConfig.organisationName
    });

    if (error) {
      console.warn('RPC setup warning:', error.message);
      // Fallback: try to set context manually if RPC fails
      await supabase.rpc('clear_current_user_context');
    }
  } catch (error) {
    console.warn('Session setup error:', error);
  }
}

/**
 * Helper function to query a table with RLS enforcement
 */
async function queryTableWithRLS(tableName: string, userConfig: typeof TEST_USERS.staff) {
  if (!supabase) {
    return { data: null, error: new Error('Supabase client not available') };
  }

  try {
    // Set up the user context using RPC function
    const { error: contextError } = await supabase.rpc('set_current_user_context', {
      user_id: `mock-${userConfig.email.replace('@', '-').replace('.', '-')}`,
      customer_type: userConfig.customerType,
      user_role: userConfig.userRole,
      organisation_name: userConfig.organisationName
    });

    if (contextError) {
      console.warn(`Context setup error for ${userConfig.email}:`, contextError.message);
      // Fallback: try to query with service role (should show all data)
      const { data, error } = await supabase
        .from(tableName)
        .select('*');
      
      return { data, error, note: 'Used service role (bypassed RLS)' };
    }

    // Query with RLS context applied
    const { data, error } = await supabase
      .from(tableName)
      .select('*');

    return { data, error, note: 'Used RLS context' };
  } catch (error) {
    console.warn(`Query error for ${tableName}:`, error);
    return { data: null, error: error as Error, note: 'Query failed' };
  }
}

/**
 * Helper function to get organization ID by name
 */
async function getOrganizationId(orgName: string): Promise<string | null> {
  if (!supabase) {
    console.warn('Supabase client not available');
    return null;
  }

  const { data, error } = await supabase
    .from('organisations')
    .select('id')
    .eq('name', orgName)
    .single();

  if (error || !data) {
    console.warn(`Organization ${orgName} not found:`, error?.message);
    return null;
  }

  return data.id;
}

describe('RLS Validation Live Tests', () => {
  let testResults: {
    staff: { [key: string]: number };
    partner: { [key: string]: number };
    enterprise: { [key: string]: number };
  } = {
    staff: {},
    partner: {},
    enterprise: {}
  };

  beforeAll(async () => {
    console.log('üß™ Starting RLS Validation Live Tests...');
    console.log('üìä Testing with live Supabase data and RLS policies');
    
    // Skip tests if Supabase is not configured
    if (!supabase) {
      console.log('‚ö†Ô∏è Skipping RLS validation tests - Supabase not configured');
      console.log('üí° To run these tests, set REQUIRE_SUPABASE=true and provide Supabase credentials');
      return;
    }
  });

  test('Staff User (DigitalQatalyst) - Multi-Organization Access', async () => {
    // Skip test if Supabase is not configured
    if (!supabase) {
      console.log('‚ö†Ô∏è Skipping Staff User test - Supabase not configured');
      return;
    }
    
    const userConfig = TEST_USERS.staff;
    console.log(`\nüë§ Testing Staff User: ${userConfig.email}`);

    // Test multiple tables
    const tables = ['contents', 'services', 'eco_business_directory', 'eco_growth_areas', 'eco_zones'];
    
    for (const tableName of tables) {
      const { data, error } = await queryTableWithRLS(tableName, userConfig);
      
      if (error) {
        console.warn(`‚ùå Error querying ${tableName}:`, error.message);
        testResults.staff[tableName] = 0;
      } else {
        const count = data?.length || 0;
        testResults.staff[tableName] = count;
        console.log(`  üìã ${tableName}: ${count} records`);
      }
    }

    // Staff should have access to multiple organizations
    const totalRecords = Object.values(testResults.staff).reduce((sum, count) => sum + count, 0);
    expect(totalRecords).toBeGreaterThan(0);
    
    console.log(`‚úÖ Staff User Results: ${totalRecords} total records across all tables`);
  });

  test('Partner User (Beta Industries) - Single Organization Access', async () => {
    // Skip test if Supabase is not configured
    if (!supabase) {
      console.log('‚ö†Ô∏è Skipping Partner User test - Supabase not configured');
      return;
    }
    
    const userConfig = TEST_USERS.partner;
    console.log(`\nüë§ Testing Partner User: ${userConfig.email}`);

    // Get the partner organization ID
    const orgId = await getOrganizationId(userConfig.organisationName);
    if (!orgId) {
      console.warn(`‚ö†Ô∏è Partner organization ${userConfig.organisationName} not found`);
      return;
    }

    // Test multiple tables
    const tables = ['contents', 'services', 'eco_business_directory', 'eco_growth_areas', 'eco_zones'];
    
    for (const tableName of tables) {
      const { data, error } = await queryTableWithRLS(tableName, userConfig);
      
      if (error) {
        console.warn(`‚ùå Error querying ${tableName}:`, error.message);
        testResults.partner[tableName] = 0;
      } else {
        const count = data?.length || 0;
        testResults.partner[tableName] = count;
        
        // Verify all records belong to the partner's organization
        if (data && data.length > 0) {
          const allOwnRecords = data.every((record: any) => 
            record.organisation_id === orgId || record.organization_id === orgId
          );
          
          if (!allOwnRecords) {
            console.warn(`‚ö†Ô∏è Partner user can see records from other organizations in ${tableName}`);
          } else {
            console.log(`  üìã ${tableName}: ${count} records (all own organization)`);
          }
        } else {
          console.log(`  üìã ${tableName}: ${count} records`);
        }
      }
    }

    // Partner should have access to their organization's records only
    const totalRecords = Object.values(testResults.partner).reduce((sum, count) => sum + count, 0);
    console.log(`‚úÖ Partner User Results: ${totalRecords} total records (single organization)`);
  });

  test('Enterprise User (Enterprise Corp) - Access Restricted', async () => {
    // Skip test if Supabase is not configured
    if (!supabase) {
      console.log('‚ö†Ô∏è Skipping Enterprise User test - Supabase not configured');
      return;
    }
    
    const userConfig = TEST_USERS.enterprise;
    console.log(`\nüë§ Testing Enterprise User: ${userConfig.email}`);

    // Test multiple tables
    const tables = ['contents', 'services', 'eco_business_directory', 'eco_growth_areas', 'eco_zones'];
    
    for (const tableName of tables) {
      const { data, error } = await queryTableWithRLS(tableName, userConfig);
      
      if (error) {
        // Enterprise users should get 403 errors
        if (error.message.includes('403') || error.message.includes('forbidden')) {
          console.log(`  üö´ ${tableName}: Access denied (403) - as expected`);
          testResults.enterprise[tableName] = 0;
        } else {
          console.warn(`‚ùå Unexpected error querying ${tableName}:`, error.message);
          testResults.enterprise[tableName] = 0;
        }
      } else {
        const count = data?.length || 0;
        testResults.enterprise[tableName] = count;
        console.log(`  üìã ${tableName}: ${count} records`);
      }
    }

    // Enterprise should have no access or very limited access
    const totalRecords = Object.values(testResults.enterprise).reduce((sum, count) => sum + count, 0);
    expect(totalRecords).toBe(0);
    
    console.log(`‚úÖ Enterprise User Results: ${totalRecords} total records (access restricted)`);
  });

  test('Print Summary Results', () => {
    console.log('\nüìä RLS Validation Summary:');
    console.log('================================');
    
    // Staff results
    const staffTotal = Object.values(testResults.staff).reduce((sum, count) => sum + count, 0);
    console.log(`‚úÖ Staff: ${staffTotal} records (multi-org access)`);
    
    // Partner results
    const partnerTotal = Object.values(testResults.partner).reduce((sum, count) => sum + count, 0);
    console.log(`‚úÖ Partner: ${partnerTotal} records (single-org access)`);
    
    // Enterprise results
    const enterpriseTotal = Object.values(testResults.enterprise).reduce((sum, count) => sum + count, 0);
    console.log(`‚úÖ Enterprise: ${enterpriseTotal} records (access restricted)`);
    
    console.log('\nüéØ RLS Policy Validation:');
    console.log(`- Staff users can access records from multiple organizations: ${staffTotal > 0 ? '‚úÖ' : '‚ùå'}`);
    console.log(`- Partner users can only access their organization's records: ${partnerTotal >= 0 ? '‚úÖ' : '‚ùå'}`);
    console.log(`- Enterprise users are blocked from accessing records: ${enterpriseTotal === 0 ? '‚úÖ' : '‚ùå'}`);
  });
});

/**
 * Additional utility function to test specific RLS policies
 */
export async function testSpecificRLSPolicy(
  tableName: string,
  userConfig: typeof TEST_USERS.staff,
  expectedBehavior: 'allow' | 'deny' | 'filter'
) {
  const { data, error } = await queryTableWithRLS(tableName, userConfig);
  
  switch (expectedBehavior) {
    case 'allow':
      expect(error).toBeNull();
      expect(data).toBeDefined();
      break;
    case 'deny':
      expect(error).toBeDefined();
      expect(error?.message).toMatch(/403|forbidden|unauthorized/i);
      break;
    case 'filter':
      expect(error).toBeNull();
      expect(data).toBeDefined();
      // Additional filtering logic would go here
      break;
  }
  
  return { data, error };
}
